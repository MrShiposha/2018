****
# Введение <a name="1"></a>

Воплощение потенциала идей, заложенных в концепцию Интернета вещей, способно существенно изменить уклад современной экономики. Благодаря внедрению масштабируемых облачных решений, использованию большого количества датчиков и распределенных микропроцессорных систем уже в ближайшее время могут быть созданы прорывные решения в таких областях, как: транспорт, сельское хозяйство, промышленное производство, здравоохранение, социальная сфера, быт и других. Все большее количество компаний обращает внимание на применение идей и технологий Интернета вещей для внедрения аналитики их деятельности и поиска новых возможностей для продуктов и услуг.

> *Интернет вещей (англ. Internet of Things, IoT) — это концепция вычислительной сети физических объектов («вещей»), оснащённых встроенными технологиями для взаимодействия друг с другом или с внешней средой.*
> 

Перечислим некоторые интересные факты:
-   По оценкам специалистов, к 2020 году к сети Интернет будет подключено до 50 млрд устройств, 20 млрд из них будут задействованы в инфраструктуре IoT.

![Прогноз количества устройств, подключенных к сети Интернет](assets/intro01.jpg)

-   До 90% данных, анализируемых устройствами Интернета вещей ранее не подвергались обработке.
-   До 60% данных, получаемых устройствами Интернета вещей, остаются актуальными лишь несколько миллисекунд.
-   В настоящее время только 0,1% устройств, способных выполнять полезную вычислительную нагрузку, подключены к сети.

По данным аналитических агенств растет количество проектов применения технологий IoT в медицине. Аналитики обнаружили, что 17% из передовых медицинских проектов используют концепцию IoT, а почти 30% проектов работают над интеграцией технологий в медицинскую практику. Статистика ясно показывает: медицинские компании заинтересованы в работе с новыми технологиями и готовы сотрудничать с разработчиками новых решений.

Однако, существенной проблемой при реализации проектов IoT в медицине является уязвимость данных. Серверы, используемые для подключения устройств IoT и обмена критическими медицинскими данными, должны обладать высокой надежностью. Одним из решений, повышающих надежность хранения информации является технология блокчейн, которая способна защитить процесс хранения посредством децентрализации и шифрования. 
Применение технологии блокчейн позволит получать и анализировать информацию о здоровье пациента, передаваемую устройствами, находящимися в контакте с пациентом. При этом становится возможным получать оперативную информацию и использовать ее для различных целей. Возможными преимуществами такого оперативного контроля за состоянием пациентов могут являтся: оперативное реагирование, оптимизация расходов, повышеие качества медицинских услуг.

****
## Инфраструктура типового решения IoT <a name="11"></a>

> 
>Под типовым решением Интернета вещей в данном конкурсе понимается распределенная кибер-физическая система, интегрирующая вычислительные ресурсы в физические процессы. В такой системе должны быть реализованы следующие основные функции:
> 

-   Сбор первичных данных с помощью сенсоров, расположенных в непосредственной близости от реальных объектов.
-   Управление объектами через актуаторы, подключенные к микрокомпьютерам.
-   Передача первичных данных от микрокомпьютеров в вычислительный хаб и в обратном направлении.
-   Первичная обработка данных в вычислительном хабе, формирование пакетов данных для передачи их в облако.
-   Получение и хранение данных в облаке.
-   Аналитическая обработка в облаке и формирование ключевых показателей эффективности (KPI) на основе данных об объектах, данных от сторонних источников, исторических данных.
-   Визуализация данных и результатов анализа на различных платформах: мобильных устройствах, носимой электронике, планшетах, компьютерах, мониторах и пр.
-   Прием команд от внешних управляющих консолей.
-   Принятие решений на основе KPI и команд, выработка управляющих и информационных сообщений для актуаторов.
-   Передача управляющих сообщений в вычислительные хабы.

Примером подобной системы является структура, представленная на следующем рисунке.

![Пример решения Интернета вещей](assets/intro03.png)
**Пример решения Интернета вещей**

> 
> Мы используем в качестве примера распределенную систему мониторинга состояния пациентов на основе системы смарт-контрактов.***
> 
> Смарт-контракт (англ. Smart contract — умный контракт) — компьютерный алгоритм, предназначенный для заключения и поддержания коммерческих контрактов в технологии блокчейн.
> 

Системы смарт-контрактов позволяют сохранить информацию о произошедших событиях в надежном и распределенном хранилище, построенной по технологии цепочки блоков (blockchain). Это обеспечивает следующие преимущества подобных систем, которые могут быть применены в области медицины:

- Надежное хранение последовательности событий и невозможность искажения ранее записанной информации.
- Открытый доступ к информации о событиях и, как следствие, открытая аналитика на основе данных системы blockchain.
- Использование данных для взаимодействия потребителей и  поставщиков (пациентов и клиник, покупателей и производителей лекарств, страховых компаний и клиник и т.п.)

Стоит сразу отметить, что данные о здоровье человека являются персональными данными, в связи с чем ее использование должно быть деперсонализированы. Поэтому вся информация персонального характера должна храниться в закрытых хранилищах. Мы используем приватную облачную платформу для реализации функций хранения.


****
## Template-проект хакатона <a name="11"></a>

Всем командам предлагается собрать template-проект, который может быть модифицирован командами для реализации собственных идей.  
В проекте использовано следующее оборудование:

-   Смартфон под управлением операционной системы `Android` или `IOS` в качестве средства диагностики состояния пациента.
-   Микрокомпьютер `RaspberryPi` используется в качестве вычислительного хаба для сбора данных с датчиков и средств диагностики состояния пациента.
-   Облачная платформа `IBM Cloud Private` используется для реализации сервисов аналитической обработки и визуализации данных о пациентах в приватном медицинском учреждении (с возможностью полного доступа к персональной информации).
-   Блокчейн-платформа `Hyperledger Fabric` используется для реализации публичного распределенного реестра сервиса хранения деперсонифицированной информации.

Система работает следующим образом. 

Пациент использует медицинский прибор для измерения некоторых параметров состояния (артериального давления, уровня сахара в крови, пульса, и т.д). Возможно также использование диалоговой диагностической системы или чат-ботов, выявляющих и анализирующих состояние человека. Мы будем использовать мобильный телефон для сбора первичных данных. 

Далее, мобильный телефон передает данные через беспроводной интерфейс (мы используем беспроводную сеть WiFi) на вычислительных хаб (одноплатный компьютер `Raspberry Pi`).  На вычислительном хабе функционируют Node.js сервер, который выполняет первичную обработку данных, и, при необходимости ее деперсонализацию. 

Данные из вычислительного хаба передаются в облачную платформу `IBM Cloud Private`, в которой развернут сервисы хранения и визуализации данных. На основе этой информации врач может принять решение о проведении дополнительных процедур, выписке пациенту необходимых лекарство, дополнительной консультативной поддержки и прочих обоснованных действиях, вытекающих из истории наблюдений.

![Функциональная схема проекта](assets/hackathon04_2018.png)
**Функциональная схема проекта**


Для формировании истории наблюдений, используемых другими специалистами, а также сторонними участниками, деперсонализированная информация сохраняется в публичной blockchain платформе `Hyperledger Fabric`. Мы развернем кластер `Hyperledger Fabric` на публичной облачной платформе `IBM Cloud`.
 



****
# День 1 <a name="day1"></a>

## Raspberry Pi <a name="21"></a>
> Raspberry Pi — одноплатный компьютер размером с банковскую карту, изначально разработанный как бюджетная система для обучения информатике, 
впоследствии получивший намного более широкое применение и популярность, чем ожидали его авторы. 
>


![Raspberry PI](assets/raspberry01.jpg)
**Raspberry PI**

На плате размером с кредитную карту вы найдёте всё то, что можете найти в обычном персональном компьютере: процессор, оперативную память, 
разъёмы HDMI, USB, Ethernet, аналоговые аудио- и видеовыходы. Кроме того, на плате расположены 40 контактов ввода/вывода общего назначения. К 
ним вы сможете подключать периферию для взаимодействия с внешним миром: исполнительные устройства вроде реле и сервомоторов или же любые 
сенсоры; в общем всё, что работает от электричества.

Штатной операционной системой для Raspberry Pi является Linux. Она устанавливается на micro-SD карту, а та в свою очередь — в специальном 
слоте на плате. Если вы не знаете Linux, не стоит пугаться. Напротив: этот компьютер — прекрасная возможность во всём разобраться. Потерять 
данные или сильно напортачить с настройками не так страшно, ведь образ на SD-карте можно восстановить за считанные минуты. После этого можно 
продолжить эксперименты с чистого листа или с определённой контрольной точки.

****
## Порты и аппаратные интерфейсы <a name="22"></a>

Для подключения монитора или телевизора используются композитный видеовыход или разъём HDMI. Кроме того, заводские OEM ЖК-экраны могут быть 
подключены через интерфейс DSI.
Raspberry Pi 2 Model B предоставляет 4 USB-порта, объединённых внутренним хабом. К ним, помимо всего прочего, можно подключить клавиатуру и 
мышь.

В качестве низкоуровневых интерфейсов доступны:

- 40 портов ввода-вывода общего назначения
- UART (Serial)
- Шина I²C/TWI
- Шина SPI с селектором между двумя устройствами
- Пины питания: 3,3 В, 5 В и земля

Колонки или наушники могут быть подключены через стандартное гнездо для 3,5 мм джеков. Также звук может передаваться через интерфейс HDMI.
На Raspberry Pi Model B+ доступен Ethernet-адаптер на 10/100 Мбит с выходом на стандартное гнездо 8P8C (RJ45).

****
## Распиновка платы <a name="23"></a>

![Распиновка Raspberry](assets/raspberry02.jpg)
**Распиновка Raspberry**

****
## Питание <a name="24"></a>

Raspberry Pi Model B+ может быть запитана через microUSB-кабель или через пины питания.
Номинальное напряжение питания — 5 В. Компьютер потребляет до 800 мА без внешних устройств.
Аппаратный выключатель питания на плате отсутствует. Для включения компьютера достаточно просто подсоединить кабель питания. Для выключения 
используйте штатную функцию операционной системы.

****
## Разбор тестового примера:<a name="25"></a> 

Берем Raspberry и аккуратно достаем карту памяти из прозрачного бокса.

![](assets/raspberry04.png)

Прежде всего нужно установить SD-карту с операционной системой Raspbian в соответствущее гнездо на плате Raspberry. В гнезде плата фиксируется 
благодаря блокирующему механизму. Для надежного закрепления нужно аккуратно вдавить пальцем карту в гнездо.

![](assets/raspberry05.png)

****
## Настройка SSH соединения с Raspberry Pi <a name="26"></a>

Используя ОС Linux выполнить подключение к RPi можно следующим образом:

```sh
ssh pi@XX.XX.XX.XX
```

где XX.XX.XX.XX - ранее определенный ip адрес устройства. 

Если вы работаете в ОС Windows, то вам нужно воспользоваться программой Putty.
В поле Имя хоста указываем ip адрес Raspberry в сети, порт 22 и тип подключения SSH.

Пароль пользователя pi: raspberry

****
## Как узнать адрес Raspberry? <a name="27"></a>

* В Ubuntu выполните команду *sudo nmap –sn < ip-адрес компьютера >/< маска >*.  Пример:

 *sudo nmap -sn 192.168.1.0/24 -p 22*

* В Windows скачайте любое приложение, сканирующее адреса (к примеру, Advanced IP Scanner). Просканируйте сеть, в которой находится компьютер.
* В списке найдите устройство с именем, подобным “Raspberry PI”.
Если вы обнаружите несоклько микрокомпьютеров “Raspberry PI” в вашей сети, вам понадобится узнать т.н. MAC адрес устройства - уникальный идентификатор сетевого устройства, состоящий из 6 байт. Узнать его можно по команде:

```shell
$ ifconfig
$ eth0      Link encap:Ethernet  HWaddr `28:d2:44:69:2a:c8` 
```

Также вы можете определить вашу плату по уникальному имени устройства `hostname` в файле /etc/hosname:
```shell
$ cat /etc/hostame
$ host10
```
Для удобства мы написали последние 6 цифр MAC адреса на разъеме Ethernet вашей платы.
В исключительном случае вы можете обнаружить вашу плату опытным путем, отключая и подключая свой Pi к сети.


****
## Полезные команды для работы в ОС Raspbian <a name="28"></a>

-   "top" — запуск предустановленного в Raspbian диспетчера задач;
-   "sudo raspi-config" — запуск первоначального меню настроек;
-   "sudo passwd root" — создание пароля для пользователя root;
-   "startx" — запуск графической оболочки;
-   "sudo halt" — выключение RPi;
-   "logout" — выход из системы;
-   "sudo reboot" — перезагрузка RPi;
-   "cd" — переход в необходимую директорию, например, для перехода в директорию /etc/network/ - "cd /etc/network/"
-   "pwd" — путь до текущей директории;
-   "dir" — содержимое текущей директории;
-   "mkdir" — создание директории. Например, "mkdir /home/pitest/" создаст директорию "pitest";
-   "rmdir" — удаление директории. Например, "mdir /home/pitest/" - удаление директории "pitest";
-   "cat" — открыть файл для чтения. Например, "cat /etc/network/interfaces" покажет содержимое файла "interfaces";
-   "nano" — открыть файл для редактирования. Например, "nano
-   /etc/network/interfaces" откроет для редактирования файл "interfaces";
-   "ifconfig" — отобразит текущую конфигурацию сети;
-   "df" — выведет в консоли свободное и используемое дисковое пространство для всех разделов файловой системы;
-   "clear" — очистить экран терминала;
-   "Ctrl"+"Ins" — скопировать выделенное (текст);
-   "Shift"+"Ins" — вставить из буфера (текст);
-   "sudo" — выполнения команд c правами root пользователя. Например, это актуально, если вы зашли под пользователем "pi" и хотите из консоли 
отредактировать какой-нибудь системный файл - "sudo nano путь_до_файла";
-   "Ctrl"+"C" — остановка текущего действия/выход из консольного приложения;
-   "sudo apt-get update" — обновление списка доступных пакетов;
-   "sudo apt-get upgrade" — обновление установленных пакетов;
-   "sudo apt-get install" — установка необходимого пакета. Например, для
установки консольного браузера Links вводим "sudo apt-get install links".

****
##Установка программного обеспечения для точки доступа WiFi <a name="29"></a>
Для начала установим dhcp-сервер и программное обеспечение hostapd для организации беспроводной точки доступа

```sh
sudo apt-get update
sudo apt-get install hostapd isc-dhcp-server
```

****
## Настройка dhcp-сервера <a name="2a"></a>

Правим файл /etc/dhcp/dhcpd.conf:

```sh
sudo nano /etc/dhcp/dhcpd.conf
```

Находим строки

option domain-name "example.org";
option domain-name-servers ns1.example.org, ns2.example.org;

и меняем их закомментировав решеткой #

```sh
 #option domain-name "example.org";
 #option domain-name-servers ns1.example.org, ns2.example.org;
```

Раскомментируем следующую строку:

```sh
 # If this DHCP server is the official DHCP server for the local
 # network, the authoritative directive should be uncommented.
 authoritative;
```

Добавляем настройки WiFi сети:

```sh
subnet 192.168.1.0 netmask 255.255.255.0 {
range 192.168.1.10 192.168.1.50;
option broadcast-address 192.168.1.255;
option routers 192.168.1.1;
default-lease-time 600;
max-lease-time 7200;
option domain-name "local";
option domain-name-servers 8.8.8.8, 8.8.4.4;
}
```

Сохраняем файл. 

Далее правим файл /etc/default/isc-dhcp-server

```sh
sudo nano /etc/default/isc-dhcp-server
```

Указываем имя интерфейсав строке:

```sh
INTERFACES=”wlan0″
```

Сохраняем и закрываем файл.

Далее отключаем wlan0

```sh
sudo ifdown wlan0
sudo nano /etc/network/interfaces
```

Вместо ```auto wlan0```, записываем:


```sh
iface wlan0 inet static
address 192.168.1.1
netmask 255.255.255.0
```

Сохраняем и закрываем файл.

```sh
sudo service networking restart
```

****
## Настройка точки доступа WiFi <a name="2b"></a>


Устанавливаем настройки точки доступа. Создадим новый кофигурацийний файл

```sh
sudo nano /etc/hostapd/hostapd.conf
```

В файл запишем следующие строки:

```sh
interface=wlan0
driver=rtl871xdrv
ssid=hackathon_team_001_ssid !!! Укажите уникальное ssid вашей сети
hw_mode=g
channel=6
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=hackathon_team_001_passwd !!! Укажите пароль 
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
```

Сохраняем и закрываем.

Разрешаем использование конфигурационного файл:

```sh
sudo nano /etc/default/hostapd
```

Правим строку:

```sh
DAEMON_CONF=”/etc/hostapd/hostapd.conf”.
```

Сохраняем файл.


****
## Настройка NAT (Network Address Translation) и тестирование <a name="2c"></a>

Установка NAT позволит многим клиентам подключаться к WiFi и получать все данные через единую Ethernet IP.

```sh
sudo nano /etc/sysctl.conf
```

Добавляем в конец net.ipv4.ip_forward=1. 

Сохраняем.

Разрешаем форвардинг пакетов ip4.

```sh
sudo sh -c "echo 1 > /proc/sys/net/ipv4/ip_forward"
```

Запускаем следующие команды для настройки сетевой трансляции между ethernet портом eth0 и wifi портом wlan0. 

```sh
sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT
sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT
```

Проверяем таблицы:

```sh
sudo iptables -t nat -S
sudo iptables -S
```

Сохраняем настройки iptables и разрешаем автоматическую загрузку настроек:

```sh
sudo sh -c "iptables-save > /etc/iptables.ipv4.nat"
```

Далее:

```sh
sudo nano /etc/network/interfaces 
```

Добавляем в конец файла:

```sh
up iptables-restore < /etc/iptables.ipv4.nat
```

Запускаем точку доступа:

```sh
sudo /usr/sbin/hostapd /etc/hostapd/hostapd.conf
```

После этого указанная Вами точка доступа должна появиться в списке доступных WiFi сетей. Вы можете подключить ваш Raspberry Pi к сети Internet кабелем Ethernet.
Если на ноутбуке или смартфоне, подключенном к Raspberry Pi удается загрузить страницу в браузере, настройка выполнено верно. 

Настрои автоматический запуск WiFi при загрузке Raspbery Pi:

```sh
sudo service hostapd start
sudo service isc-dhcp-server start
sudo update-rc.d hostapd enable
sudo update-rc.d isc-dhcp-server enable
```

****
## Установка Node.js на Raspberry Pi <a name="2d"></a>

В этом задании нам необходимо разработать и запустить клиент-серверного приложение, используя Raspberry Pi в качестве сервера, компьютер или смартфон в качестве клиента.
Клиент и сервер будут находиться в одной локальной сети WiFi, настроенной нами ранее.

В качестве серверного узла выступает (Node.js + Express),
в качестве клиента - браузер (js + html).


Для этого выполните команды для установки Node.js:

```sh
sudo apt-get update
sudo apt-get install nodejs
```

Проверьте, установились ли пакеты:
```sh
node -v
v8.4.0
npm -v
5.3.0
```

Если пакет `npm` (Node.js Package Manager) не установлен и не показывает версию,
то необходимо его установить отдельно командой `sudo apt-get install npm`

## Запуск hello-сервера на Raspberry Pi <a name="2e"></a>

1. Создайте папку `hello`: ```sh mkdir hello```
2. Перейдите в нее и выполните команду `npm init` (все опции оставлять по умолчанию)
В вашей папке появился файл `package.json`, в нем будут храниться зависимости проекта и параметры запуска.
3. Далее необходимо установить веб-фреймворк `Express` для обработки запросов, маршрутизации и раздачи статики.
`npm install express --save` (`--save` сохранит зависимость в `package .json`, в нем появилась строчка `"dependencies": {"express": "^4.16.4"}`)

```json
{
  "name": "hello",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.16.4"
  }
}
```
4. Создайте файл с кодом сервера `index.js`

```js
"use strict";

// подключаем фреймвок express
let express = require('express');
let app = express();

// разрешаем междоменные запросы
app.use(function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
    res.header("Cache-Control", "no-cache, no-store, must-revalidate");
    next();
});

// hello-GET, вывод сообщения в браузере 'Hello Pi'
app.get('/api/hello', function (req, res) {
    res.send('Hello Pi');
});

// слушаем на порту 5055 или другом свободном
let port = process.env.PORT || 5055;
app.listen(port);
console.log("Server works on port " + port);
```
5. Выполните команду для запуска скрипта `node index.js` (в терминале должно появиться сообщение, что сервер работает)
6. Чтобы проверить работу, в браузере перейдите по адресу `http://localhost:5005/api/hello`.
Должно появиться сообщение `Hello Pi`

> Можно в `package.json` добавить скрипт `"start":"node index.js"` и запускать приложение командой `npm start`

> Чтобы выключить сервер, в его терминале используйте сочетание клавиш `Ctrl + C`



## Подготовка к запуску стартовых приложений <a name="2f"></a>

Запуск стартовых приложений на клиенте (ноутбук с браузером) и сервере (Raspberry Pi).

На клиентском устройстве необходимо повторить предыдущие шаги установки Node.js  и веб-фреймворка Express, так как на клиенте надо будет иметь сервер со статикой для веб-интерфейса!!!



Скачать примеры из репозитория на клиентский и серверный узел `https://github.com/alexbmstu/2018.git`
На Raspberry Pi понадобится папка `server`, на клиенте - `client`

На сервере (Raspberry Pi):

```sh
cd ~
mkdir nodejs
cd ./nodejs
wget https://github.com/alexbmstu/2018/raw/master/src/server.zip
unzip server.zip
```

Аналогичные действие выпоните на клиенте (ноутбуке или смартфоне), заменив `server` на `client`

### Действия на сервере <a name="2f01"></a>
1. На Raspberry Pi перейдите в папку `server`
2. Для установки зависимостей выполните `npm install`
3. Для запуска сервера выполните `npm start`
4. Сервер готов к запросам

### Действия на клиенте <a name="2f02"></a>
1. На устройстве перейдите в папку `client`
2. Для установки зависимостей выполните `npm install`
3. Для запуска сервера выполните `npm start`
4. Для перехода к веб-интерфейсу в браузере перейдите по адресу сервера `http://localhost:5007/`

> Для тестирования веб-интерфейса поднимите и основной сервер на вашем компьютере

**Задание**: поменять url запросов и порты работы серверов таим образом,
чтобы запросы можно было пересылать с веб-интерфейса на сервер-обработчик Raspberry Pi

****
# День 3 <a name="day3"></a>


## IBM Cloud Private <a name="31"></a>
# День 5 <a name="day5"></a>

## Облачная платформа *IBM Cloud* <a name="51"></a>



***IBM Cloud*** — это открытое облачное предложение типа PaaS
(*Platform-as-a-Service*) на базе проекта с открытым исходным кодом Cloud Foundry. Эта платформа предназначена для разработки и хостинга приложений, а также упрощения задач по управлению инфраструктурой. Она позволяет быстро создавать и развертывать приложения, а также управлять ими.

***IBM Cloud*** обеспечивает следующие возможности:

-   быстрое и инкрементное составление приложений из сервисов;
-   непрерывное внесение изменений в приложения и обеспечение постоянной доступности;
-   поддержка высокоспециализированных моделей программирования и сервисов для конкретных рабочих нагрузок;
-   встраивание высокой степени управляемости в сервисы и приложения;
-   оптимизация и эластичная адаптация к рабочей нагрузке.


![Каталог компонентов IBM Cloud](assets/intro04.jpg)
**Каталог компонентов IBM Cloud**


Платформа *IBM Cloud* достигает этих целей посредством абстрагирования и скрытия большинства сложностей, традиционно сопутствующих хостингу приложений в облаке и управлению ими в облачной среде. *IBM Cloud* может быть использована разработчиками для создания и применения самых разных приложений, включая веб-приложения, мобильные приложения, приложения для работы с большими данными, приложения для разумных устройств и т.д. *IBM Cloud* поддерживает разработку на популярных языках программирования и средах разработки. Java-технологии, средства создания серверных частей для мобильных приложений, мониторинг приложений, технологии с открытым исходным кодом и т. д. — все эти возможности
доступны в облаке как сервисы.

Каталог *IBM Cloud* содержит большую часть из того, что необходимо для быстрого начала работы, большое количество шаблонов, заранее сконфигурированны наборов сервисов, сред исполнения и примеров кода, готовых к использованию:

-   сред исполнения, в том числе: Liberty for Java, Node.js, Ruby on Rails;
-   веб-сервисов и сервисов приложений, в том числе: Data/Session Cache,  ElasticMQ, Decision, SSO, Log Analysis, Redis, RabbitMQ, Twilio;
-   мобильных сервисов, в том числе: push-уведомлений, Cloud Code,     Mobile Application Management, Mobile Quality Assurance;
-   сервисов управления данными, в том числе: MongoDB, реляционной базы данных от IBM, JSON-базы данных от IBM, MySQL, PostgreSQL, MobileData, Mobile Sync, BLU Data Warehouse, MapReduce;
-   сервисов мониторинга и анализа;
-   сервисов DevOps Services (прежнее название: JazzHub).


****
## Краткое описание концепций *IBM Cloud* <a name="52"></a>


В терминологии *IBM Cloud* приложение (*application*) — это созданный вами артефакт, т. е. весь программный код (исходный код или исполняемые двоичные файлы), который необходимо запустить или на который необходимо сослаться в процессе исполнения. Мобильные приложения выполняются за пределами среды *IBM Cloud* и используют сервисы *IBM Cloud*, представленные приложениями. В случае веб-приложений приложение — это код, загруженный на платформу *IBM Cloud* с целью хостинга. Кроме того, платформа *IBM Cloud* способна осуществлять хостинг программного кода приложения, который вы хотите выполнять на внутреннем сервере в среде на базе контейнера.

На рисунке показаны принципы взаимодействия *IBM Cloud* с клинтскими приложениями.


![Принципы взаимодействия *IBM Cloud* с клинтскими приложениями](assets/intro05.jpg)
**Принципы взаимодействия *IBM Cloud* с клинтскими приложениями**


***Сервис (service)*** — это код, работающий на платформе *IBM Cloud* и предлагающий некоторую функциональность, которую могут использовать приложения. Это может быть готовый сервис, используемый непосредственно — например, push-уведомления для мобильных приложений или эластичное кэширование для веб-приложения. Вы также можете создавать собственные сервисы в диапазоне от простых служебных функций до сложной
бизнес-логики.

***Организация (organization) и пространство (space)*** — это организационные единицы инфраструктуры, способные хранить и отслеживать ресурсы приложения. Организация содержит домены (domain), пространства и пользователей. Пространство содержит приложения и сервисы. По умолчанию используется три пространства: Development (разработка), Production (производство) и Staging (подготовка). Для приложений, которым требуется среда типа PaaS, предоставляются buildpack-пакеты, каждый из которых представляет собой набор скриптов для подготовки кода к исполнению на целевой PaaS-платформе. Buildpack-пакеты, которые включают необходимую вашим приложениям среду исполнения и могут также содержать специализированные инфраструктуры, упрощают развертывание приложения в облаке по сравнению с самостоятельной установкой и конфигурированием среды исполнения.

Использование сервисов в *IBM Cloud* включает три этапа:
1.  Сообщите платформе *IBM Cloud*, что вам требуется новый экземпляр сервиса и какое конкретное приложение будет использовать этот новый экземпляр.
2.  *IBM Cloud* автоматически инициализирует новый экземпляр этого сервиса и свяжет его с приложением.
3.  Приложение взаимодействует с сервисом.

***Пакеты сервисов (Service bundles)*** — это коллекции API-интерфейсов, используемых в конкретных областях. Например, пакет Mobile Services включает сервисы MobileData, Cloud Code, Push и Mobile Application Management. Доступные сервисы и среды исполнения представлены в каталоге IBM Cloud. Кроме того, вы можете зарегистрировать собственные сервисы.

****
## Развертывание и управление приложением <a name="53"></a>

Чтобы развернуть свое приложение, необходимо загрузить его в среду *IBM Cloud* и указать, сколько экземпляров этого приложения должно исполняться, а затем сконфигурировать *IBM Cloud*, введя необходимую информацию для поддержки этого приложения.

В случае мобильного приложения среда *IBM Cloud* содержит артефакт, который представляет серверную часть мобильного приложения — набор сервисов, который использует приложение для взаимодействия с сервером. *IBM Cloud* поддерживает серверные компоненты мобильного приложения, взаимодействующие с сервисами PushWorks, Cloud Code и Mobile Data, непосредственно из пользовательского интерфейса *IBM Cloud*.

В случае веб-приложения необходимо предоставить в *IBM Cloud* соответствующую информацию о среде исполнения и среде разработки, чтобы платформа смогла сформировать надлежащую инфраструктуру для исполнения этого приложения.

При развертывании приложений и управлении ими можно использовать инструмент командной строки cf, веб-интерфейс *IBM Cloud* или сервисы DevOps Services.

Браузерные и мобильные клиенты — а также другие приложения, развернутые на платформе *IBM Cloud* и выполняющиеся за ее пределами — взаимодействуют с приложениями, работающими на платформе *IBM Cloud*, через API-интерфейсы типа REST/HTTP. Каждый клиентский запрос маршрутизируется к одному из экземпляров приложения или составляющих его сервисов. Среды исполнения приложений в *IBM Cloud* изолированы друг от друга даже тогда, когда они находятся на одной и той же физической машине.

В ходе управления приложениями можно запускать, останавливать, перезапускать экземпляры приложения (или, в случае веб-приложения, изменять их количество), а также изменять объем памяти, используемый приложением. Ключевая конструктивная особенность *IBM Cloud* — отличные показатели при хостинге масштабируемых приложений и артефактов приложений. На данный момент эта платформа не масштабирует приложение автоматически в соответствии с нагрузкой, поэтому этим процессом необходимо управлять самостоятельно посредством создания или удаления экземпляров при изменении рабочей нагрузки. По этой причине ваши приложения должны сохранять все персистентные данные за пределами приложения в одном из сервисов хранения данных, предоставляемых платформой *IBM Cloud*. При повторном развертывании приложения после обновления используется тот же процесс, что и при начальном развертывании. *IBM Cloud* останавливает все исполняющиеся экземпляры и переводит новые экземпляры в рабочее состояние автоматически.

****
## Сервисы DevOps Services для *IBM Cloud* <a name="54"></a>

При использовании DevOps Services требуется лишь несколько простых шагов для организации взаимодействия с другими специалистами с целью планирования, отслеживания и создания программного обеспечения в облаке. Вы можете воспользоваться встроенным в браузер редактором программного кода, который DevOps Services предоставляет для разработки приложений, или использовать DevOps Services с Eclipse, с VisualStudio или с инструментом командной строки Git для написания кода приложения и развертывания его на платформе IBM Cloud.

При работе с пользовательским интерфейсом, который помогает разработчику быстро добавлять сведения "кто", "что" и "когда" для своего рабочего проекта, требуется потратить всего несколько минут на задание дат, документирование первого сценария применения, назначение одной-двух задач и переход непосредственно к написанию программного кода.

DevOps Services включает встроенные средства управления исходным кодом — Jazz SCM и хостинговый Git. Каждый проект получает свой собственный репозиторий DevOps Services и рабочее пространство, в котором участники этого проекта могут регистрироваться свои изменения, ассоциировать изменения программного кода и просматривать историю недавних изменений. Кроме того, вы можете создать проект DevOps Services и указать на свой репозиторий GitHub.

Вы также можете с легкостью связать элементы работы с изменениями кода в GitHub. Кроме того, для написания кода в Git вы можете использовать имеющиеся у вас инструменты.

Типичными сценариями использования ресурса DevOps Services являются:

-   Создание приложения для анализа данных социальных сетей с использованием Node.js, Node-RED, Express, sentiment и ntwitter.
-   Создание приложения для создания интерактивных опросов в реальном     времени с использованием Node.js, Node-RED, Express, AngularJS и MongoDB.
-   Построение сервисов уведомления с использованием Node.js, Node-RED и MongoDB.
-   Создание приложений для управления аппаратными устройствами c использованием Node-RED и IoT компонент.

****
## Блокчейн технологии <a name="55"></a>


Смарт-контракт – это запрограммированная бизнес-логика и правила взаимодействия с данными, которые размещены в распределенном реестре (ledger). Реестр содержит цепочку блоков транзакций, которые совершили участники сети. Каждый последующий блок хранит хэш предыдущего блока, за счет чего обеспечивается невозможность изменения части информации. Процесс согласования корректности блока и добавления его в распределенный реестр называется консенсусом. Различные блокчейн-платформы имеют различные механизмы консенсуса: proof of work (PoW), proof of stake (PoS), byzantine fault tolerance (BFT) и прочие.
Начиная с версии 1.0 HLF специфична наличием Ordering Service, который является распределенным между участниками кластером и отвечает за очередность транзакций в формирующемся блоке. По сконфигурированным параметрам он собирает транзакции в сети и формирует блок. В случае отказа Ordering Service транзакции в сети перестанут регистрироваться, но сами данные останутся неизменными.

Как развернуть kubernetes сеть в IBM Cloud.

Для того, чтобы начать пользоваться IBM Cloud необходимо:


зарегистрироваться;
установить IBM Cloud CLI;
получить и активировать купон для активации дополнительного функционала в IBM Cloud (купоны выдаются в полуручном режиме, и их, к сожалению, ограниченное количество);
установить kubectl;
установить клиент Git для вашей операционной системы;
почитать о том, что такое Docker и Kubernetes.

После регистрации в IBM Cloud вы получите доступ в графический интерфейс управления вашей инфраструктурой. Вам будут доступны сотни сервисов и десятки подходов для размещения ваших приложений (Cloud Foundry, Kubernetes, OpenWhisk, виртуальные машины и выделенные сервера). Для использования виртуальных машин и выделенных серверов необходимо добавить кредитную карту, а вот небольшой кусочек kubernetes можно получить бесплатно (с купоном выше).
Для этого необходимо в левом верхнем углу нажать на кнопку меню и выбрать Containers.
Перед вами откроется панель управления кластерами kubernetes, Docker registry и helm-чартами.


Выбрав слева в меню пункт Cluster, вы увидите интерфейс создания кластера kubernetes и выбор региона, в котором кластер будет развернут. Вы можете создать бесплатный кластер в каждом регионе.
После нажатия кнопки Create cluster следует выбрать тип кластера Free и придумать ему название.


Создание кластера займет некоторое время, которое вы можете потратить на переход в консоль (заварить кофе вы не успеете). Установив IBM Cloud CLI (bx tool) вам необходимо сконфигурировать его для работы с вашим аккаунтом:


установить плагин для bx для работы с kubernetes;
bx plugin install container-service -r IBM Cloud Private
авторизоваться в IBM Cloud;
bx login -a https://api.eu-gb.IBM Cloud Private.net
указать регион, где вы создали Ваш кластер (uk-south может меняться);
bx cs region-set uk-south
запросить конфигурацию для вашего кластера, где mycluster — название, которые Вы ввели в графическом интерфейсе IBM Cloud;
bx cs cluster-config mycluster
выполнить команду, которую вы увидите в результате выполнения предыдущего шага. Она укажет утилите kubectl, где находятся ключи доступа к вашему кластеру (путь к конфигурационному файлу может меняться);
export KUBECONFIG=/path/mycluster/kube-config-mil01-mycluster.yml
узнать public IP вашего kubernetes worker.
bx cs workers mycluster

Теперь вы готовы к тому, чтобы начать использовать ваш kubernetes-кластер для любых целей. Кластер является бесплатным, и в его функционале есть некоторые ограничения, которые нам не помешают развернуть свою блокчейн-сеть:


ограничения бесплатного кластера
Для тех, кто первый раз использует kubernetes, возможно, стоит поэкспериментировать с разворачиванием первых Deployment и сервисов. Те, кто уже готов окунутся в мир разработки блокчейн-проектов, могут переходить к следующим шагам.


Разворачиваем контейнеры HLF в kubernetes

Для тех, кто не так давно работает с Docker и Kubernetes напомню, что для разворачивания любого приложения в kubernetes нам необходимы 2 вещи:


Docker images, на основе которых происходит запуск контейнера;
yaml-конфигурация поведения нашего контейнера в kubernetes.

Open Source сообщество разработчиков Hypeledger Fabric сделало за нас эту работу. Docker Images с HLF уже лежат на DockerHub и автоматически загрузятся в наш кластер. А вся yaml-конфигурация находится в github репозитории. На момент написания статьи репозиторий содержит конфигурацию для Hyperledger Fabric 1.0.3. Возвращаемся в консоль и выполняем следующие команды:


git clone https://github.com/IBM-Blockchain/ibm-container-service.git
cd ibm-container-service/cs-offerings/scripts/
./create_all.sh --with-couchdb

Ключ --with-couchdb необходим для того, чтобы вместо базы данных по умолчанию у нас развернулась CouchDB. С ее помощью мы сможем использовать запросы для получения данных из HLF Composer.


https://habr.com/company/ibm/blog/351808/




ПО RPI3 https://stackoverflow.com/questions/41520341/issue-with-bluetooth-connection-raspberry-pi3-and-nodejs-7-4-0
Установка ICP https://www.youtube.com/watch?v=eQwOOTzjM24&feature=youtu.be

apt install apt-transport-https ca-certificates curl software-properties-common python-minimal jq
sysctl -w vm.max_map_count=262144 \
swapoff -a \
sudo sed -i '/ swap / s/^/#/' /etc/fstab \
echo "vm.max_map_count=262144" >> /etc/sysctl.conf 
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository    "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
sudo apt-get update
apt-cache madison docker-ce
apt install docker-ce=18.03.1~ce-0~ubuntu
docker --version
docker
docker pull ibmcom/icp-inception:3.1.0
mkdir /opt/ibm-cloud-private-ce-2.1.0.3;   cd /opt/ibm-cloud-private-ce-2.1.0.3
sudo docker run -e LICENSE=accept  -v "$(pwd)":/data ibmcom/icp-inception:2.1.0.3 cp -r cluster /data
ssh-keygen -b 4096 -f ~/.ssh/id_rsa -N ""
cat ~/.ssh/id_rsa.pub | sudo tee -a ~/.ssh/authorized_keys
systemctl restart sshd
cp ~/.ssh/id_rsa ./cluster/ssh_key
ls /opt/ibm-cloud-private-ce-3.1.0/cluster/
ifconfig
cd cluster/
ls
nano hosts 
sudo docker run --net=host -t -e LICENSE=accept -v "$(pwd)":/installer/cluster ibmcom/icp-inception:2.1.0.3 install

docker run -e LICENSE=accept --net=host -v /usr/local/bin:/data ibmcom/icp-inception:2.1.0.3 cp /usr/local/bin/kubectl /data
echo  -n "x4fsQKLM" | base64

eDRmc1FLTE0=

kubectl -n kube-system edit secrets platform-auth-idp-credentials


kubectl -n kube-system delete pods -l k8s-app=auth-idp



kubectl config set-cluster cluster.local --server=https://195.19.40.201:8001 --insecure-skip-tls-verify=true




Развертывание Fabric

https://github.com/IBM/blockchain-network-on-kubernetes/blob/master/README.md



























****
# Дополнительные источники <a name="a001"></a>

<a name="pub1">[1]</a> [Учебные материалы по IBM Cloud Private](https://www.ibm.com/cloud/garage/tutorials/ibm-cloud-private-trial/ibm-cloud-private-hosted-trial)

<a name="pub1">[2]</a> [Инструкции по развертыванию IBM Cloud Private на виртуальной машине десктопа](https://github.com/IBM/deploy-ibm-cloud-private)

<a name="pub1">[3]</a> [Инструкции по развертыванию IBM Cloud Private на сервере](https://www.ibm.com/support/knowledgecenter/en/SSBS6K_2.1.0.2/installing/install_containers_CE.html)

<a name="pub1">[4]</a> [Docker образы IBM Cloud Private CE 2.1](https://hub.docker.com/r/ibmcom/icp-inception/)



